# Canvas Plugin Development

Use Bun for all development:

- `bun run src/cli.ts` - Run CLI
- `bun test` - Run tests
- `bun install` - Install dependencies

## Structure

```
canvas/
├── src/           # TypeScript source code
│   ├── cli.ts     # CLI entry point
│   ├── terminal.ts # Terminal detection & spawning
│   ├── canvases/  # Canvas components (React/Ink)
│   ├── scenarios/ # Scenario definitions
│   ├── ipc/       # IPC server/client
│   └── api/       # High-level API
├── skills/        # Skill documentation
├── commands/      # User commands
└── package.json   # Plugin dependencies
```

## Terminal Architecture

`terminal.ts` handles detection and spawning across 8 terminal types:

| Terminal | Detection | Spawn Method | Reuse |
|----------|-----------|--------------|-------|
| tmux | `TMUX` env var | `split-window -h` | Send keys to existing pane |
| iTerm2 | `TERM_PROGRAM=iTerm.app` / `ITERM_SESSION_ID` | AppleScript vertical split | AppleScript send to session |
| Kitty | `TERM_PROGRAM=kitty` / `KITTY_PID` | `kitty @ launch --location=vsplit` | `kitty @ send-text` |
| WezTerm | `TERM_PROGRAM=WezTerm` | `wezterm cli split-pane --right` | `wezterm cli send-text` |
| Alacritty | `TERM_PROGRAM=Alacritty` / `ALACRITTY_SOCKET` | New window (`alacritty -e`) | Kill PID + respawn |
| VS Code | `TERM_PROGRAM=vscode` / `VSCODE_INJECTION` | Detached process | Kill PID + respawn |
| Ghostty | `TERM_PROGRAM=ghostty` / `GHOSTTY_RESOURCES_DIR` | New window (`ghostty -e`) | Kill PID + respawn |
| Apple Terminal | `TERM_PROGRAM=Apple_Terminal` | AppleScript new window | AppleScript `do script` in window |

Priority order: iTerm2 > tmux > Kitty > WezTerm > Alacritty > VS Code > Ghostty > Apple Terminal.

Each terminal tracks its canvas instance (pane ID, session ID, window ID, or PID) in `/tmp/claude-canvas-*` files for reuse.

## Adding a New Canvas Type

1. Create component in `src/canvases/`
2. Register scenarios in `src/scenarios/`
3. Add skill in `skills/[name]/SKILL.md`
4. Update main canvas skill

## IPC Protocol

Canvases communicate via Unix domain sockets:

```typescript
// Canvas → Controller
{ type: "ready", scenario }
{ type: "selected", data }
{ type: "cancelled" }

// Controller → Canvas
{ type: "update", config }
{ type: "close" }
```


<claude-mem-context>
# Recent Activity

<!-- This section is auto-generated by claude-mem. Edit content outside the tags. -->

*No recent activity*
</claude-mem-context>